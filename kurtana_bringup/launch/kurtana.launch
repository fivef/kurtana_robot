<?xml version="1.0"?>
<launch>

   <arg name="kinect_camera_name" default="kinect" />
   <arg name="stereo" default="false" />
   <arg name="flatten_table" default="true"/>

    <!-- start up world -->
  <include file="$(find gazebo_worlds)/launch/empty_world.launch" />

  <!-- load jaco urdf -->
  <!-- send urdf to param server -->
  <param name="robot_description" command="$(find xacro)/xacro.py '$(find kurtana_bringup)/urdf/kurtana.urdf.xacro'" />


  <!-- load hand description needed for cluster grasp planner -->
  <rosparam command="load" file="$(find kurtana_bringup)/config/hand_description.yaml"/>

  <!-- start gripper grasp planner cluster -->
  <node name="robotiq_hand_grasp_planner_cluster" pkg="pr2_gripper_grasp_planner_cluster" 
    type="point_cluster_grasp_planner_server.py" respawn="false" output="screen">
    <rosparam command="load" file="$(find kurtana_bringup)/config/robotiq_hand_virtual_gripper_model.yaml" />
	<param name="z_up_frame" value="/base_link"/>
  </node>  



  
  <!-- push robot_description to factory and spawn robot in gazebo -->
  <node name="spawn_jaco_model" pkg="gazebo" type="spawn_model" args="-urdf -param robot_description -model jaco " respawn="false" output="screen" />

  <!-- state publisher -->
        <node name="robot_state_publisher" pkg="robot_state_publisher" type="state_publisher" />	

  <include file="$(find jaco_gazebo_controller_configuration)/launch/joint_trajectory_controller.launch" />

  

    <!-- alternative option: database server running on a local machine -->
  <rosparam command="load" file="$(find household_objects_database)/config/wgs36.yaml"/>
  <node pkg="household_objects_database" name="objects_database_node" type="objects_database_node"
    respawn="true" output="screen"/>   
    
   <node name="cluster_bounding_box_finder" pkg="object_manipulator" cwd="node"
    type="cluster_bounding_box_finder_server.py" output="screen" respawn="false" >
    <param name="z_up_frame" value="/base_link" />
  </node>
    
    <!-- tabletop collision map processing -->
  <node pkg="tabletop_collision_map_processing" name="tabletop_collision_map_processing"
    type="tabletop_collision_map_processing_node" respawn="false" output="screen" />
  <param name="tabletop_collision_map_processing/get_model_mesh_srv"
    value="/objects_database_node/get_model_mesh" />
  <param name="tabletop_collision_map_processing/static_map_cloud_name" value="/kinect/depth_registered/points"/>
  
    <!-- tabletop segmentation and object recognition -->
  <include file="$(find kurtana_bringup)/launch/tabletop_object_detector/tabletop_complete.launch">
    <arg unless="$(arg stereo)" name="tabletop_segmentation_points_input" value="$(arg kinect_camera_name)/depth_registered/points"/>
    <arg if="$(arg stereo)" name="tabletop_segmentation_points_input" value="narrow_stereo_textured/points2"/>
    <arg name="flatten_table" value="$(arg flatten_table)"/>
  </include>
  


  <!-- joint_commander: use dynamic_reconfigure to adjust the rack configuration manually -->
  <!-- node publishes on kurtana_joint_states -->
  <node name="joint_commander" pkg="kurtana_pole_joint_commander" type="joint_commander">
    <param name="kurtana_roll_joint" type="double" value="0.00" />
    <param name="kurtana_pitch_joint" type="double" value="0.5" />

    <param name="publish_joint_states" type="bool" value="True" />
    <param name="publish_controller_commands" type="bool" value="True" />

    <!--<remap from="joint_states" to="kurtana_joint_states" />-->
  </node>


  <!-- start the joint_state_muxer to merge the joint_states from the rack and the arm 
  <rosparam param="source_list">[kurtana_joint_states, katana_joint_states, wheel_joint_states]</rosparam>
  <node pkg="joint_state_muxer" type="joint_state_muxer" name="joint_state_muxer" output="screen" />-->


  <!-- Kinect driver -->
  <include file="$(find openni_launch)/launch/openni.launch">
    <arg name="camera" value="kinect" />
    <arg name="publish_tf" value="false" />
    <arg name="depth_registration" value="true" />
  </include>


</launch>

